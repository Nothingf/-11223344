<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lumière Noël</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300;400&display=swap');
    
    body {
      margin: 0;
      background-color: #051008;
      color: #e5e7eb;
      font-family: 'Lato', sans-serif;
      overflow: hidden;
    }
    
    h1, h2, h3, .serif {
      font-family: 'Cinzel', serif;
    }

    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: #0f2e1a; }
    ::-webkit-scrollbar-thumb { background: #d4af37; border-radius: 3px; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="importmap">
  {
    "imports": {
      "three": "https://esm.sh/three@0.160.0",
      "three/": "https://esm.sh/three@0.160.0/",
      "react": "https://esm.sh/react@18.2.0",
      "react/": "https://esm.sh/react@18.2.0/",
      "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
      "react-dom": "https://esm.sh/react-dom@18.2.0",
      "react-dom/": "https://esm.sh/react-dom@18.2.0/",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
      "@react-three/drei": "https://esm.sh/@react-three/drei@9.92.7?external=react,react-dom,three,@react-three/fiber",
      "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.15.12?external=react,react-dom,three,@react-three/fiber",
      "maath": "https://esm.sh/maath@0.10.7?external=three",
      "maath/": "https://esm.sh/maath@0.10.7/",
      "uuid": "https://esm.sh/uuid@9.0.1"
    }
  }
  </script>
  <script type="module">
// ============================================
// IMPORTS
// ============================================
import React, { useState, useCallback, useEffect, useRef, useMemo } from 'react';
import { createRoot } from 'react-dom/client';
import * as THREE from 'three';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import { Environment, OrbitControls, Stars, Sparkles, RoundedBox } from '@react-three/drei';
import { EffectComposer, Bloom, Vignette, Noise } from '@react-three/postprocessing';
import { easing } from 'maath';
import { v4 as uuidv4 } from 'uuid';

// MediaPipe loaded dynamically
let FilesetResolver, HandLandmarker;

// ============================================
// CONSTANTS
// ============================================
const COLORS = {
  MATTE_GREEN: new THREE.Color('#237a48'),
  METALLIC_GOLD: new THREE.Color('#d4af37'),
  CHRISTMAS_RED: new THREE.Color('#8a1c1c'), 
  SILVER: new THREE.Color('#c0c0c0'),
  LIGHT_WARM: new THREE.Color('#ffdb70'),
  LIGHT_COOL: new THREE.Color('#e0f7fa'),
  LIGHT_RED: new THREE.Color('#ff0000'),
  LIGHT_GREEN: new THREE.Color('#00ff44'),
  LIGHT_GOLD: new THREE.Color('#ffaa00'),
  GLITTER: new THREE.Color('#fff7cc'),
  WOOD: new THREE.Color('#5d4037'),
};

const CONFIG = {
  PARTICLE_COUNT: 1350, 
  GLITTER_COUNT: 2700, 
  TREE_HEIGHT: 13,
  TREE_RADIUS_BOTTOM: 4.8,
  CAMERA_DEFAULT_POS: [0, 1, 14],
  ANIMATION_SPEED: 0.05,
};

const PALETTE = [
  COLORS.MATTE_GREEN,
  COLORS.MATTE_GREEN,
  COLORS.METALLIC_GOLD,
  COLORS.CHRISTMAS_RED,
  COLORS.METALLIC_GOLD, 
  COLORS.SILVER,
];

const LIGHT_PALETTE = [
  COLORS.LIGHT_GOLD,
  COLORS.LIGHT_GOLD,
  COLORS.LIGHT_GOLD,
  COLORS.LIGHT_WARM,
  COLORS.LIGHT_GREEN,
  COLORS.LIGHT_GREEN,
  COLORS.LIGHT_GREEN,
  COLORS.LIGHT_RED,
];

// ============================================
// STORAGE SERVICE
// ============================================
const STORAGE_KEY = 'lumiere_noel_photos_v1';
const MAX_IMAGE_DIMENSION = 800; 
const JPEG_QUALITY = 0.7;

const processImageFile = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = (event) => {
      const img = new Image();
      img.src = event.target?.result;
      img.onload = () => {
        const canvas = document.createElement('canvas');
        let width = img.width;
        let height = img.height;
        if (width > height) {
          if (width > MAX_IMAGE_DIMENSION) {
            height *= MAX_IMAGE_DIMENSION / width;
            width = MAX_IMAGE_DIMENSION;
          }
        } else {
          if (height > MAX_IMAGE_DIMENSION) {
            width *= MAX_IMAGE_DIMENSION / height;
            height = MAX_IMAGE_DIMENSION;
          }
        }
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            reject(new Error('Could not get canvas context'));
            return;
        }
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL('image/jpeg', JPEG_QUALITY);
        resolve(dataUrl);
      };
      img.onerror = (err) => reject(err);
    };
    reader.onerror = (err) => reject(err);
  });
};

const saveToStorage = (photos) => {
  try {
    const json = JSON.stringify(photos);
    localStorage.setItem(STORAGE_KEY, json);
    return true;
  } catch (e) {
    console.error("Storage failed:", e);
    alert("保存失败：照片总大小超过了浏览器存储限制。");
    return false;
  }
};

const loadFromStorage = () => {
  try {
    const json = localStorage.getItem(STORAGE_KEY);
    if (!json) return null;
    return JSON.parse(json);
  } catch (e) {
    console.error("Failed to load photos:", e);
    return null;
  }
};

// Load photos from remote photos.json
const loadRemotePhotos = async () => {
  try {
    const response = await fetch('photos/photos.json');
    if (!response.ok) return null;
    const photoUrls = await response.json();
    return photoUrls;
  } catch (e) {
    console.error("Failed to load remote photos:", e);
    return null;
  }
};

// ============================================
// GESTURE RECOGNITION SERVICE
// ============================================
const detectGesture = (landmarks) => {
  if (!landmarks || landmarks.length < 21) return 'NONE';

  const dist = (p1, p2) => {
    return Math.sqrt(
      Math.pow(p1.x - p2.x, 2) + 
      Math.pow(p1.y - p2.y, 2) + 
      Math.pow(p1.z - p2.z, 2)
    );
  };

  const thumbTip = landmarks[4];
  const indexTip = landmarks[8];
  const middleTip = landmarks[12];
  const ringTip = landmarks[16];
  const pinkyTip = landmarks[20];
  const wrist = landmarks[0];

  const tips = [indexTip, middleTip, ringTip, pinkyTip];
  const avgDistToWrist = tips.reduce((acc, tip) => acc + dist(tip, wrist), 0) / 4;
  const pinchDist = dist(thumbTip, indexTip);

  if (avgDistToWrist < 0.4) return 'FIST';
  if (pinchDist < 0.06) return 'PINCH';
  if (avgDistToWrist > 0.5) return 'OPEN_PALM';
  return 'NONE';
};

const calculateHandRotation = (landmarks) => {
  const wrist = landmarks[0];
  const middleMCP = landmarks[9];
  const centerX = (wrist.x + middleMCP.x) / 2;
  return (centerX - 0.5) * 2;
};

// ============================================
// SVG ICONS
// ============================================
const IconUpload = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" },
  React.createElement('path', { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }),
  React.createElement('polyline', { points: "17 8 12 3 7 8" }),
  React.createElement('line', { x1: 12, y1: 3, x2: 12, y2: 15 })
);

const IconHand = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: 20, height: 20, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round", className: "w-4 h-4 md:w-5 md:h-5 flex-shrink-0" },
  React.createElement('path', { d: "M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0" }),
  React.createElement('path', { d: "M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2" }),
  React.createElement('path', { d: "M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8" }),
  React.createElement('path', { d: "M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" })
);

const IconGripHorizontal = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: 20, height: 20, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round", className: "w-4 h-4 md:w-5 md:h-5 flex-shrink-0" },
  React.createElement('circle', { cx: 12, cy: 9, r: 1 }),
  React.createElement('circle', { cx: 19, cy: 9, r: 1 }),
  React.createElement('circle', { cx: 5, cy: 9, r: 1 }),
  React.createElement('circle', { cx: 12, cy: 15, r: 1 }),
  React.createElement('circle', { cx: 19, cy: 15, r: 1 }),
  React.createElement('circle', { cx: 5, cy: 15, r: 1 })
);

const IconMaximize = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: 20, height: 20, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round", className: "w-4 h-4 md:w-5 md:h-5 flex-shrink-0" },
  React.createElement('path', { d: "M8 3H5a2 2 0 0 0-2 2v3" }),
  React.createElement('path', { d: "M21 8V5a2 2 0 0 0-2-2h-3" }),
  React.createElement('path', { d: "M3 16v3a2 2 0 0 0 2 2h3" }),
  React.createElement('path', { d: "M16 21h3a2 2 0 0 0 2-2v-3" })
);

const IconRotateCcw = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: 20, height: 20, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round", className: "w-4 h-4 md:w-5 md:h-5 flex-shrink-0" },
  React.createElement('path', { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" }),
  React.createElement('path', { d: "M3 3v5h5" })
);

const IconImage = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" },
  React.createElement('rect', { width: 18, height: 18, x: 3, y: 3, rx: 2, ry: 2 }),
  React.createElement('circle', { cx: 9, cy: 9, r: 2 }),
  React.createElement('path', { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" })
);

const IconX = ({ size = 24 }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" },
  React.createElement('path', { d: "M18 6 6 18" }),
  React.createElement('path', { d: "m6 6 12 12" })
);

const IconChevronDown = ({ size = 24 }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" },
  React.createElement('path', { d: "m6 9 6 6 6-6" })
);

const IconChevronUp = ({ size = 24 }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" },
  React.createElement('path', { d: "m18 15-6-6-6 6" })
);

const IconSave = ({ size = 14, id, className }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round", id, className },
  React.createElement('path', { d: "M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z" }),
  React.createElement('path', { d: "M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7" }),
  React.createElement('path', { d: "M7 3v4a1 1 0 0 0 1 1h7" })
);

// ============================================
// SHADER CODE
// ============================================
const PARTICLE_SHADER_HEAD = `
  uniform float uTime;
  uniform float uProgress;
  uniform float uSpin;
  
  attribute vec3 aTreePos;
  attribute vec3 aScatterPos;
  attribute vec3 aMeta;
  attribute vec3 aRotationSpeed;
  
  mat4 rotationMatrix(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
  }

  mat4 rotateY(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat4(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
  }
`;

const PARTICLE_SHADER_BODY = `
  vec3 targetPos = mix(aTreePos, aScatterPos, uProgress);
  if (uProgress > 0.01) {
      float floatAmount = sin(uTime + aMeta.z) * 0.05 * uProgress;
      targetPos.y += floatAmount;
  }
  vec4 worldPos = rotateY(uSpin) * vec4(targetPos, 1.0);
  float currentScale = aMeta.x;
  if (aMeta.y > 0.0) {
      float flash = sin(uTime * aMeta.y + aMeta.z);
      float intensity = 1.0 + flash * 0.3; 
      currentScale *= intensity;
  }
  currentScale *= (1.0 + uProgress * 0.3);
  vec3 transformedLocal = position * currentScale;
  if (length(aRotationSpeed) > 0.0) {
      mat4 rotX = rotationMatrix(vec3(1,0,0), uTime * aRotationSpeed.x);
      mat4 rotY = rotationMatrix(vec3(0,1,0), uTime * aRotationSpeed.y);
      transformedLocal = (rotY * rotX * vec4(transformedLocal, 1.0)).xyz;
  }
  transformedLocal = (rotateY(uSpin) * vec4(transformedLocal, 1.0)).xyz;
  vec3 finalPosition = transformedLocal + worldPos.xyz;
  vec3 transformed = finalPosition;
`;

const PARTICLE_NORMAL_FIX = `
  float s_n = sin(uSpin);
  float c_n = cos(uSpin);
  mat2 m_n = mat2(c_n, -s_n, s_n, c_n);
  objectNormal.xz = m_n * objectNormal.xz;
`;

const injectShader = (shader, uniformsRef) => {
  shader.uniforms.uTime = { value: 0 };
  shader.uniforms.uProgress = { value: 0 };
  shader.uniforms.uSpin = { value: 0 };
  uniformsRef.current = shader.uniforms;
  shader.vertexShader = PARTICLE_SHADER_HEAD + shader.vertexShader;
  shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', PARTICLE_SHADER_BODY);
  shader.vertexShader = shader.vertexShader.replace('#include <beginnormal_vertex>', `#include <beginnormal_vertex>\n${PARTICLE_NORMAL_FIX}`);
};

// ============================================
// STAR COMPONENT
// ============================================
const starShape = new THREE.Shape();
const outerRadius = 0.8;
const innerRadius = 0.35;
const starPoints = 5;
for (let i = 0; i < starPoints * 2; i++) {
  const r = i % 2 === 0 ? outerRadius : innerRadius;
  const a = (i / (starPoints * 2)) * Math.PI * 2;
  const x = Math.cos(a + Math.PI / 2) * r;
  const y = Math.sin(a + Math.PI / 2) * r;
  if (i === 0) starShape.moveTo(x, y);
  else starShape.lineTo(x, y);
}

const Star = ({ mode }) => {
  const groupRef = useRef(null);
  
  useFrame((state, delta) => {
    if (!groupRef.current) return;
    const t = state.clock.getElapsedTime();
    
    if (mode === 'ASSEMBLED') {
        groupRef.current.rotation.y = -t * 0.1;
    } else {
        groupRef.current.rotation.y += delta * 0.2;
    }

    const floatY = Math.sin(t * 1.5) * 0.1;
    const topOfTreeY = CONFIG.TREE_HEIGHT / 2;
    const targetY = (mode === 'DISPERSED' || mode === 'FOCUS')
      ? topOfTreeY + 9 
      : topOfTreeY + 0.8 + floatY;

    const smoothTime = mode === 'DISPERSED' ? 0.4 : 0.5;
    easing.damp(groupRef.current.position, 'y', targetY, smoothTime, delta);
    
    const scale = 1 + Math.sin(t * 4) * 0.05;
    groupRef.current.scale.setScalar(scale);
  });

  return React.createElement('group', { ref: groupRef, position: [0, CONFIG.TREE_HEIGHT / 2, 0] },
    React.createElement('mesh', { castShadow: true, receiveShadow: true },
      React.createElement('extrudeGeometry', { args: [starShape, { depth: 0.15, bevelEnabled: true, bevelSize: 0.02, bevelThickness: 0.02, bevelSegments: 1 }] }),
      React.createElement('meshStandardMaterial', { 
        color: COLORS.METALLIC_GOLD, 
        emissive: COLORS.METALLIC_GOLD, 
        emissiveIntensity: 8,
        roughness: 0.1,
        metalness: 1.0,
        toneMapped: false
      })
    ),
    React.createElement('pointLight', { intensity: 8, distance: 15, color: "#ffd700", decay: 2 })
  );
};

// ============================================
// ORNAMENTS COMPONENT
// ============================================
const Ornaments = ({ mode, rotationOffset }) => {
    const giftsRef = useRef(null);
    const ballsRef = useRef(null);
    const lightsRef = useRef(null);
    const glitterRef = useRef(null);
    
    const smoothedRotation = useRef(rotationOffset);
    const spinVelocity = useRef(0);
    const accumulatedSpin = useRef(0);
    const prevMode = useRef(mode);
    const progressRef = useRef(0);
    const uniformsRefs = useRef([]);

    const { gifts, balls, lights, glitters } = useMemo(() => {
        const giftList = [];
        const ballList = [];
        const lightList = [];
        const glitterList = [];

        const getSphericalPos = (minR, maxR) => {
             const r = minR + Math.random() * (maxR - minR);
             const theta = 2 * Math.PI * Math.random();
             const phi = Math.acos(2 * Math.random() - 1);
             return [r * Math.sin(phi) * Math.cos(theta), r * Math.cos(phi), r * Math.sin(phi) * Math.sin(theta)];
        };

        for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
            const rand = Math.random();
            let category;
            if (rand < 0.25) category = 'GIFT';
            else if (rand < 0.55) category = 'BALL';
            else category = 'LIGHT';

            let color, scale, flashSpeed = 0;

            if (category === 'GIFT') {
                color = PALETTE[Math.floor(Math.random() * PALETTE.length)];
                scale = Math.random() * 0.12 + 0.15; 
                if (Math.random() < 0.1) flashSpeed = 2 + Math.random() * 3;
            } else if (category === 'BALL') {
                color = PALETTE[Math.floor(Math.random() * PALETTE.length)];
                scale = Math.random() * 0.1 + 0.12; 
                if (Math.random() < 0.3) flashSpeed = 3 + Math.random() * 4;
            } else {
                color = LIGHT_PALETTE[Math.floor(Math.random() * LIGHT_PALETTE.length)];
                scale = Math.random() * 0.04 + 0.03;
                if (Math.random() < 0.9) flashSpeed = 1 + Math.random() * 4;
            }

            const u = Math.random();
            const h = CONFIG.TREE_HEIGHT * (1 - Math.sqrt(u));
            const rMaxAtH = (CONFIG.TREE_RADIUS_BOTTOM * (CONFIG.TREE_HEIGHT - h)) / CONFIG.TREE_HEIGHT;
            const r = Math.pow(Math.random(), 0.8) * rMaxAtH; 
            const angle = Math.random() * Math.PI * 2;
            const tx = Math.cos(angle) * r;
            const tz = Math.sin(angle) * r;
            const ty = h - CONFIG.TREE_HEIGHT / 2;
            const [sx, sy, sz] = getSphericalPos(6.5, 12.0);

            const data = {
                id: i, category, position: [tx, ty, tz], treePosition: [tx, ty, tz], scatterPosition: [sx, sy, sz],
                color, scale, rotationSpeed: [Math.random(), Math.random(), Math.random()], flashSpeed, flashOffset: Math.random() * 100
            };

            if (category === 'GIFT') giftList.push(data);
            else if (category === 'BALL') ballList.push(data);
            else lightList.push(data);
        }

        for (let i = 0; i < CONFIG.GLITTER_COUNT; i++) {
             const u = Math.random();
             const h = CONFIG.TREE_HEIGHT * (1 - Math.sqrt(u));
             const rMaxAtH = (CONFIG.TREE_RADIUS_BOTTOM * (CONFIG.TREE_HEIGHT - h)) / CONFIG.TREE_HEIGHT;
             const r = Math.sqrt(Math.random()) * rMaxAtH * 1.3; 
             const angle = Math.random() * Math.PI * 2;
             const tx = Math.cos(angle) * r;
             const tz = Math.sin(angle) * r;
             const ty = h - CONFIG.TREE_HEIGHT / 2;
             const [sx, sy, sz] = getSphericalPos(6.5, 13.0);
             glitterList.push({
                id: i + 10000, category: 'LIGHT', position: [tx, ty, tz], treePosition: [tx, ty, tz], scatterPosition: [sx, sy, sz],
                color: COLORS.GLITTER, scale: Math.random() * 0.04 + 0.015, rotationSpeed: [0,0,0], flashSpeed: 3 + Math.random() * 6, flashOffset: Math.random() * 100
             });
        }
        return { gifts: giftList, balls: ballList, lights: lightList, glitters: glitterList };
    }, []);

    useEffect(() => {
        uniformsRefs.current = [];
        const groups = [
            { ref: giftsRef, data: gifts, hasShadows: true, hasRotation: true },
            { ref: ballsRef, data: balls, hasShadows: true, hasRotation: false },
            { ref: lightsRef, data: lights, hasShadows: false, hasRotation: false },
            { ref: glitterRef, data: glitters, hasShadows: false, hasRotation: false }
        ];

        groups.forEach(({ ref, data, hasShadows, hasRotation }) => {
            if (!ref.current) return;
            const count = data.length;
            const geo = ref.current.geometry;

            const aTreePos = new Float32Array(count * 3);
            const aScatterPos = new Float32Array(count * 3);
            const aMeta = new Float32Array(count * 3);
            const aRotationSpeed = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const d = data[i];
                const i3 = i * 3;
                aTreePos[i3] = d.treePosition[0]; aTreePos[i3 + 1] = d.treePosition[1]; aTreePos[i3 + 2] = d.treePosition[2];
                aScatterPos[i3] = d.scatterPosition[0]; aScatterPos[i3 + 1] = d.scatterPosition[1]; aScatterPos[i3 + 2] = d.scatterPosition[2];
                aMeta[i3] = d.scale; aMeta[i3 + 1] = d.flashSpeed; aMeta[i3 + 2] = d.flashOffset;
                if (hasRotation) { aRotationSpeed[i3] = d.rotationSpeed[0]; aRotationSpeed[i3 + 1] = d.rotationSpeed[1]; aRotationSpeed[i3 + 2] = d.rotationSpeed[2]; }
                ref.current.setColorAt(i, d.color);
            }

            geo.setAttribute('aTreePos', new THREE.InstancedBufferAttribute(aTreePos, 3));
            geo.setAttribute('aScatterPos', new THREE.InstancedBufferAttribute(aScatterPos, 3));
            geo.setAttribute('aMeta', new THREE.InstancedBufferAttribute(aMeta, 3));
            geo.setAttribute('aRotationSpeed', new THREE.InstancedBufferAttribute(aRotationSpeed, 3));
            if (ref.current.instanceColor) ref.current.instanceColor.needsUpdate = true;

            const mat = ref.current.material;
            mat.onBeforeCompile = (shader) => {
                const uRef = { current: null };
                injectShader(shader, uRef);
                if (uRef.current) uniformsRefs.current.push(uRef.current);
            };
            mat.needsUpdate = true;

            if (hasShadows) {
                const depthMat = new THREE.MeshDepthMaterial({ depthPacking: THREE.RGBADepthPacking });
                depthMat.onBeforeCompile = (shader) => {
                    const uRef = { current: null };
                    injectShader(shader, uRef);
                    if (uRef.current) uniformsRefs.current.push(uRef.current);
                };
                ref.current.customDepthMaterial = depthMat;
                const distMat = new THREE.MeshDistanceMaterial();
                distMat.onBeforeCompile = (shader) => {
                    const uRef = { current: null };
                    injectShader(shader, uRef);
                    if (uRef.current) uniformsRefs.current.push(uRef.current);
                };
                ref.current.customDistanceMaterial = distMat;
            }
        });
    }, [gifts, balls, lights, glitters]);

    useFrame((state, delta) => {
        const time = state.clock.getElapsedTime();
        if (prevMode.current !== mode) {
            if (mode === 'DISPERSED' && prevMode.current === 'ASSEMBLED') spinVelocity.current = -12.0;
            else if (mode === 'ASSEMBLED') spinVelocity.current = 20.0;
            else if (mode === 'FOCUS') spinVelocity.current = 0;
            prevMode.current = mode;
        }
        const friction = mode === 'DISPERSED' ? 0.82 : 0.85;
        spinVelocity.current *= friction; 
        accumulatedSpin.current += spinVelocity.current * delta;
        easing.damp(smoothedRotation, 'current', rotationOffset, 0.4, delta);
        const targetProgress = mode === 'ASSEMBLED' ? 0 : 1;
        const smoothTime = mode === 'DISPERSED' ? 0.4 : 0.5;
        easing.damp(progressRef, 'current', targetProgress, smoothTime, delta);
        const baseSpin = (time * 0.1) + accumulatedSpin.current;
        const handComponent = smoothedRotation.current * 3.0 * progressRef.current;
        const finalSpin = baseSpin + handComponent;
        uniformsRefs.current.forEach(uniforms => {
            if (uniforms.uTime) uniforms.uTime.value = time;
            if (uniforms.uProgress) uniforms.uProgress.value = progressRef.current;
            if (uniforms.uSpin) uniforms.uSpin.value = finalSpin;
        });
    });

    return React.createElement('group', null,
      React.createElement('instancedMesh', { ref: giftsRef, args: [undefined, undefined, gifts.length], castShadow: true, receiveShadow: true, frustumCulled: false },
        React.createElement('boxGeometry', { args: [1, 1, 1] }),
        React.createElement('meshStandardMaterial', { roughness: 0.3, metalness: 0.45, envMapIntensity: 0.25 })
      ),
      React.createElement('instancedMesh', { ref: ballsRef, args: [undefined, undefined, balls.length], receiveShadow: true, frustumCulled: false },
        React.createElement('sphereGeometry', { args: [1, 16, 16] }),
        React.createElement('meshStandardMaterial', { roughness: 0.12, metalness: 0.45, envMapIntensity: 0.25 })
      ),
      React.createElement('instancedMesh', { ref: lightsRef, args: [undefined, undefined, lights.length], frustumCulled: false },
        React.createElement('sphereGeometry', { args: [1, 8, 8] }),
        React.createElement('meshStandardMaterial', { toneMapped: false, emissiveIntensity: 8, color: "#ffffff", emissive: "#ffffff" })
      ),
      React.createElement('instancedMesh', { ref: glitterRef, args: [undefined, undefined, glitters.length], frustumCulled: false },
        React.createElement('planeGeometry', { args: [1, 1] }),
        React.createElement('meshBasicMaterial', { color: COLORS.GLITTER.clone().multiplyScalar(10), side: THREE.DoubleSide, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, toneMapped: false })
      )
    );
};

// ============================================
// PHOTO CLOUD - SHARED RESOURCES
// ============================================
let _sharedBumpMap = null;
const getSharedBumpMap = () => {
  if (_sharedBumpMap) return _sharedBumpMap;
  const width = 512, height = 512, size = width * height;
  const data = new Uint8Array(4 * size);
  for (let i = 0; i < size; i++) {
    const v = Math.random() * 255; 
    data[i * 4] = v; data[i * 4 + 1] = v; data[i * 4 + 2] = v; data[i * 4 + 3] = 255;
  }
  const texture = new THREE.DataTexture(data, width, height);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(2, 2);
  texture.needsUpdate = true;
  _sharedBumpMap = texture;
  return _sharedBumpMap;
};

// ============================================
// FRAME COMPONENT
// ============================================
const Frame = ({ data, mode, rotationOffset, isFocused, spinRef, showcaseSystemRef }) => {
  const groupRef = useRef(null);
  const [texture, setTexture] = useState(null);
  const [aspect, setAspect] = useState(1);
  const { viewport, camera } = useThree();
  const smoothedRot = useRef(rotationOffset);

  useEffect(() => {
    if (!data.url) return;
    const loader = new THREE.TextureLoader();
    loader.load(data.url, (tex) => {
      tex.colorSpace = THREE.SRGBColorSpace;
      const imgAspect = tex.image.width / tex.image.height;
      setAspect(imgAspect);
      setTexture(tex);
    });
  }, [data.url]);

  const idSeed = useMemo(() => data.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0), [data.id]);
  const bumpMap = useMemo(() => getSharedBumpMap(), []);

  useFrame((state, delta) => {
    if (!groupRef.current) return;
    const time = state.clock.getElapsedTime();
    const currentSpin = spinRef.current;

    easing.damp(smoothedRot, 'current', rotationOffset, 0.4, delta);

    let targetPos = new THREE.Vector3();
    let targetRot = new THREE.Euler();
    let targetScale = 1;
    let smoothTime = 0.5;

    const showcase = showcaseSystemRef.current;
    const participant = showcase.active[data.id];
    const isShowcaseActive = !!participant && (time >= participant.launchTime);

    if (isFocused && mode === 'FOCUS') {
      const distFromCamera = 4;
      const zPos = 22 - distFromCamera; 
      targetPos.set(0, 0, zPos); 
      targetPos.y += Math.sin(time * 1.5) * 0.15; 
      targetRot.set(Math.sin(time * 0.8) * 0.05, Math.sin(time * 0.6) * 0.05, 0);
      
      const vFOV = camera.fov * Math.PI / 180;
      const visibleHeight = 2 * Math.tan(vFOV / 2) * distFromCamera;
      const visibleWidth = visibleHeight * viewport.aspect;
      if (aspect > (visibleWidth * 0.8) / (visibleHeight * 0.8)) {
          targetScale = (visibleWidth * 0.8) / aspect; 
      } else {
          targetScale = visibleHeight * 0.8;
      }
      smoothTime = 0.4;

    } else if (isShowcaseActive && mode === 'ASSEMBLED') {
      const R = CONFIG.TREE_RADIUS_BOTTOM * 1.6;
      const myAngle = showcase.systemAngle + participant.offsetAngle;

      const bob = Math.sin(time * 2 + idSeed) * 0.5;
      targetPos.set(Math.cos(myAngle) * R, 0 + bob, Math.sin(myAngle) * R);

      const normAngle = (myAngle + Math.PI * 2) % (Math.PI * 2);
      let dist = Math.abs(normAngle - Math.PI / 2);
      if (dist > Math.PI) dist = 2 * Math.PI - dist;
      
      const isPresentationZone = dist < 0.5; 

      if (isPresentationZone && showcase.lapCounter >= 2) {
          targetRot.set(0, 0, 0);
          targetScale = 1.9;
      } else {
          targetRot.set(0, -myAngle + Math.PI / 2, 0);
          targetScale = 1.25;
      }
      smoothTime = 0.6; 

    } else if (mode === 'ASSEMBLED') {
      targetPos.set(...data.treePosition);
      const initialAngle = Math.atan2(targetPos.x, targetPos.z);
      const rotY = time * 0.1 + currentSpin;
      
      const x = targetPos.x * Math.cos(rotY) - targetPos.z * Math.sin(rotY);
      const z = targetPos.x * Math.sin(rotY) + targetPos.z * Math.cos(rotY);
      targetPos.set(x, targetPos.y, z);

      targetRot.set(0, initialAngle + rotY, 0);
      targetScale = 1.25;
      smoothTime = 0.5;

    } else {
      targetPos.set(...data.scatterPosition);
      const rotTotal = (time * 0.1) + (smoothedRot.current * 3.0) + currentSpin;
      const x = targetPos.x * Math.cos(rotTotal) - targetPos.z * Math.sin(rotTotal);
      const z = targetPos.x * Math.sin(rotTotal) + targetPos.z * Math.cos(rotTotal);
      targetPos.set(x, targetPos.y + Math.sin(time * 0.5 + idSeed) * 0.05, z);
      targetRot.set(Math.sin(time * 0.5 + idSeed) * 0.05, Math.cos(time * 0.3 + idSeed) * 0.05, 0);
      targetScale = 1.6;
      smoothTime = 0.25;
    }

    easing.damp3(groupRef.current.position, targetPos, smoothTime, delta);
    easing.dampE(groupRef.current.rotation, targetRot, smoothTime, delta);
    easing.damp(groupRef.current.scale, 'x', targetScale, smoothTime, delta);
    easing.damp(groupRef.current.scale, 'y', targetScale, smoothTime, delta);
    easing.damp(groupRef.current.scale, 'z', targetScale, smoothTime, delta);
  });

  if (!texture) return null;

  const showcase = showcaseSystemRef.current;
  const isShowcaseActive = !!showcase.active[data.id];
  const isPriority = isFocused || isShowcaseActive;
  const renderOrder = isPriority ? 100 : 1;

  const PHOTO_W = aspect, PHOTO_H = 1;
  const MAT_BORDER = 0.08, FRAME_BORDER = 0.06;
  const MAT_W = PHOTO_W + MAT_BORDER * 2, MAT_H = PHOTO_H + MAT_BORDER * 2;
  const FRAME_W = MAT_W + FRAME_BORDER * 2, FRAME_H = MAT_H + FRAME_BORDER * 2;
  const FRAME_DEPTH = 0.12; 

  return React.createElement('group', { ref: groupRef, renderOrder },
    React.createElement(RoundedBox, { args: [FRAME_W, FRAME_H, FRAME_DEPTH], radius: 0.03, smoothness: 4, castShadow: true, receiveShadow: true },
      React.createElement('meshStandardMaterial', { color: "#d4af37", roughness: 0.45, metalness: 1.0, envMapIntensity: 2.5, bumpMap, bumpScale: 0.005 })
    ),
    React.createElement('mesh', { position: [0, 0, FRAME_DEPTH / 2 + 0.001], renderOrder: renderOrder + 1, receiveShadow: true },
      React.createElement('planeGeometry', { args: [MAT_W, MAT_H] }),
      React.createElement('meshStandardMaterial', { color: "#fdfdfd", roughness: 0.9 })
    ),
    React.createElement('mesh', { position: [0, 0, FRAME_DEPTH / 2 + 0.002], renderOrder: renderOrder + 2, receiveShadow: true },
      React.createElement('planeGeometry', { args: [PHOTO_W, PHOTO_H] }),
      React.createElement('meshBasicMaterial', { map: texture, toneMapped: false })
    ),
    React.createElement('mesh', { position: [0, 0, -FRAME_DEPTH / 2 - 0.001], rotation: [0, Math.PI, 0], renderOrder: renderOrder + 1, receiveShadow: true },
      React.createElement('planeGeometry', { args: [MAT_W, MAT_H] }),
      React.createElement('meshStandardMaterial', { color: "#fdfdfd", roughness: 0.9 })
    ),
    React.createElement('mesh', { position: [0, 0, -FRAME_DEPTH / 2 - 0.002], rotation: [0, Math.PI, 0], renderOrder: renderOrder + 2, receiveShadow: true },
      React.createElement('planeGeometry', { args: [PHOTO_W, PHOTO_H] }),
      React.createElement('meshBasicMaterial', { map: texture, toneMapped: false })
    )
  );
};

// ============================================
// PHOTO CLOUD CONTROLLER
// ============================================
const PhotoCloud = ({ photos, mode, rotationOffset, focusId }) => {
  const spinVelocity = useRef(0);
  const accumulatedSpin = useRef(0);
  const spinRef = useRef(0);
  const prevMode = useRef(mode);

  const showcaseSystemRef = useRef({
      active: {},
      systemAngle: 0,
      phase: 'COOLDOWN',
      cooldownUntil: 6.0,
      lapCounter: 0
  });

  const prevSystemAngle = useRef(0);

  useFrame((state, delta) => {
    const time = state.clock.elapsedTime;
    
    if (prevMode.current !== mode) {
        if (mode === 'DISPERSED' && prevMode.current === 'ASSEMBLED') spinVelocity.current = -12.0;
        else if (mode === 'ASSEMBLED') spinVelocity.current = 20.0;
        else if (mode === 'FOCUS') spinVelocity.current = 0;
        prevMode.current = mode;
    }
    const friction = mode === 'DISPERSED' ? 0.82 : 0.85;
    spinVelocity.current *= friction; 
    accumulatedSpin.current += spinVelocity.current * delta;
    spinRef.current = accumulatedSpin.current;

    if (mode === 'ASSEMBLED' && photos.length >= 2) {
        const sys = showcaseSystemRef.current;

        if (sys.phase === 'COOLDOWN') {
            if (time > sys.cooldownUntil) {
                const candidates = photos.filter(p => p.id !== focusId);
                if (candidates.length >= 2) {
                    const idx1 = Math.floor(Math.random() * candidates.length);
                    let idx2 = (idx1 + Math.floor(candidates.length / 2)) % candidates.length;
                    if (idx1 === idx2) idx2 = (idx1 + 1) % candidates.length;
                    
                    const p1 = candidates[idx1];
                    const p2 = candidates[idx2];

                    sys.systemAngle = Math.random() * Math.PI * 2;
                    sys.phase = 'ACTIVE';
                    sys.lapCounter = 0;
                    prevSystemAngle.current = sys.systemAngle;
                    
                    sys.active = {
                        [p1.id]: { id: p1.id, offsetAngle: 0, launchTime: time, hasPresented: false, originalSlotAngle: Math.atan2(p1.treePosition[0], p1.treePosition[2]) },
                        [p2.id]: { id: p2.id, offsetAngle: Math.PI, launchTime: time + 0.7, hasPresented: false, originalSlotAngle: Math.atan2(p2.treePosition[0], p2.treePosition[2]) }
                    };
                }
            }
        } 
        else if (sys.phase === 'ACTIVE') {
            let inPresentationZone = false;
            const targetAngle = Math.PI / 2;

            for (const key in sys.active) {
                const p = sys.active[key];
                if (time >= p.launchTime) {
                    const myAngle = (sys.systemAngle + p.offsetAngle) % (Math.PI * 2);
                    const normAngle = (myAngle + Math.PI * 2) % (Math.PI * 2);
                    let dist = Math.abs(normAngle - targetAngle);
                    if (dist > Math.PI) dist = 2 * Math.PI - dist;
                    if (dist < 0.4 && sys.lapCounter >= 2) inPresentationZone = true;
                }
            }

            const speed = inPresentationZone ? 0.3 : 2.5;
            sys.systemAngle += speed * delta;

            const laps = Math.floor(sys.systemAngle / (Math.PI * 2));
            const prevLaps = Math.floor(prevSystemAngle.current / (Math.PI * 2));
            if (laps > prevLaps) sys.lapCounter++;
            prevSystemAngle.current = sys.systemAngle;
            
            for (const key in sys.active) {
                const p = sys.active[key];
                if (!p.hasPresented && time >= p.launchTime && sys.lapCounter >= 2) {
                    const myAngle = (sys.systemAngle + p.offsetAngle) % (Math.PI * 2);
                    const normAngle = (myAngle + Math.PI * 2) % (Math.PI * 2);
                    let dist = Math.abs(normAngle - targetAngle);
                    if (dist > Math.PI) dist = 2 * Math.PI - dist;
                    if (dist < 0.1) p.hasPresented = true;
                }
            }

            const toRemove = [];
            for (const key in sys.active) {
                const p = sys.active[key];
                if (p.hasPresented && !inPresentationZone) {
                    const treeRot = (time * 0.1 + spinRef.current) % (Math.PI * 2);
                    const slotWorldAngle = (treeRot + p.originalSlotAngle) % (Math.PI * 2);
                    const currentOrbitAngle = (sys.systemAngle + p.offsetAngle) % (Math.PI * 2);
                    const n1 = (currentOrbitAngle + 2*Math.PI) % (2*Math.PI);
                    const n2 = (slotWorldAngle + 2*Math.PI) % (2*Math.PI);
                    let diff = Math.abs(n1 - n2);
                    if (diff > Math.PI) diff = 2 * Math.PI - diff;
                    if (diff < 0.3) toRemove.push(key);
                }
            }

            if (toRemove.length > 0) {
                toRemove.forEach(k => delete sys.active[k]);
                if (Object.keys(sys.active).length === 0) {
                    sys.phase = 'COOLDOWN';
                    sys.cooldownUntil = time + 6.0;
                }
            }
        }
    } else {
        showcaseSystemRef.current.active = {};
        showcaseSystemRef.current.phase = 'COOLDOWN';
        showcaseSystemRef.current.lapCounter = 0;
        showcaseSystemRef.current.cooldownUntil = time + 6.0;
    }
  });

  return React.createElement('group', null,
    photos.map((photo) => React.createElement(Frame, { 
        key: photo.id, data: photo, mode, rotationOffset,
        isFocused: focusId === photo.id, spinRef, showcaseSystemRef
    }))
  );
};

// ============================================
// EXPERIENCE COMPONENT (3D Scene)
// ============================================
const Experience = ({ mode, photos, rotationOffset, focusId }) => {
  return React.createElement('div', { className: "w-full h-full absolute inset-0 bg-gradient-to-b from-gray-900 to-black" },
    React.createElement(Canvas, {
      shadows: true,
      camera: { position: [0, 0, 22], fov: 45 },
      gl: { antialias: false },
      dpr: [1, 1.5]
    },
      React.createElement('color', { attach: "background", args: ['#051008'] }),
      React.createElement('fog', { attach: "fog", args: ['#051008', 10, 50] }),
      React.createElement('ambientLight', { intensity: 0.6 }),
      React.createElement('spotLight', { position: [10, 15, 10], angle: 0.5, penumbra: 1, intensity: 3, castShadow: true, color: COLORS.METALLIC_GOLD }),
      React.createElement('pointLight', { position: [-10, -5, -10], intensity: 1.5, color: COLORS.CHRISTMAS_RED }),
      React.createElement('pointLight', { position: [0, 5, 10], intensity: 1.5, color: "#ffffff", distance: 20 }),
      React.createElement(Environment, { preset: "city" }),
      React.createElement(Stars, { radius: 100, depth: 50, count: 5000, factor: 4, saturation: 0, fade: true, speed: 1 }),
      React.createElement(Sparkles, { count: 300, scale: 20, size: 3, speed: 0.4, opacity: 0.5, color: COLORS.METALLIC_GOLD }),
      React.createElement('group', { position: [0, 0, 0] },
        React.createElement(Star, { mode }),
        React.createElement(Ornaments, { mode, rotationOffset }),
        React.createElement(PhotoCloud, { photos, mode, rotationOffset, focusId })
      ),
      React.createElement(EffectComposer, { enableNormalPass: false },
        React.createElement(Bloom, { luminanceThreshold: 1.1, mipmapBlur: true, intensity: 1.0, radius: 0.7 }),
        React.createElement(Noise, { opacity: 0.03 }),
        React.createElement(Vignette, { eskil: false, offset: 0.1, darkness: 1.0 })
      ),
      React.createElement(OrbitControls, { enableZoom: false, enablePan: false, enableRotate: false, target: [0, 0, 0] })
    )
  );
};

// ============================================
// HAND TRACKER COMPONENT
// ============================================
const HandTracker = ({ onHandUpdate }) => {
  const videoRef = useRef(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isMinimized, setIsMinimized] = useState(() => typeof window !== 'undefined' ? window.innerWidth < 768 : false);

  const stableGestureRef = useRef('NONE');
  const lastRawGestureRef = useRef('NONE');
  const gestureConsistencyCount = useRef(0);

  useEffect(() => {
    let handLandmarker = null;
    let animationFrameId;

    const setupMediaPipe = async () => {
      try {
        const mediapipe = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17/vision_bundle.mjs');
        FilesetResolver = mediapipe.FilesetResolver;
        HandLandmarker = mediapipe.HandLandmarker;
        
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );
        
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1
        });

        startWebcam();
      } catch (err) {
        console.error("MediaPipe Init Error:", err);
        setError("Failed to load AI models.");
        setLoading(false);
      }
    };

    const startWebcam = async () => {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 480, facingMode: 'user' },
            audio: false,
          });
          
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
            videoRef.current.addEventListener('loadeddata', predictWebcam);
          }
          setLoading(false);
        } catch (err) {
          console.error("Webcam Error:", err);
          setError("Camera permission denied.");
          setLoading(false);
        }
      }
    };

    let lastVideoTime = -1;
    let lastPredictionTime = 0;
    const PREDICTION_INTERVAL = 50; 

    const predictWebcam = () => {
      if (videoRef.current && handLandmarker) {
        const now = performance.now();
        
        if (now - lastPredictionTime >= PREDICTION_INTERVAL) {
            if (videoRef.current.currentTime !== lastVideoTime) {
              lastVideoTime = videoRef.current.currentTime;
              lastPredictionTime = now;
              
              const detections = handLandmarker.detectForVideo(videoRef.current, now);

              if (detections.landmarks && detections.landmarks.length > 0) {
                const landmarks = detections.landmarks[0];
                const rawGesture = detectGesture(landmarks);
                const rotation = calculateHandRotation(landmarks);
                
                if (rawGesture === lastRawGestureRef.current) {
                    gestureConsistencyCount.current++;
                } else {
                    lastRawGestureRef.current = rawGesture;
                    gestureConsistencyCount.current = 1;
                }

                if (gestureConsistencyCount.current >= 2) {
                    stableGestureRef.current = rawGesture;
                }
                
                const posX = 1 - landmarks[9].x; 
                const posY = landmarks[9].y;

                onHandUpdate({
                  gesture: stableGestureRef.current,
                  position: { x: posX, y: posY },
                  rotation,
                  isPresent: true
                });
              } else {
                 gestureConsistencyCount.current = 0;
                 lastRawGestureRef.current = 'NONE';
                 stableGestureRef.current = 'NONE';

                 onHandUpdate({
                  gesture: 'NONE',
                  position: { x: 0.5, y: 0.5 },
                  rotation: 0,
                  isPresent: false
                });
              }
            }
        }
        animationFrameId = requestAnimationFrame(predictWebcam);
      }
    };

    setupMediaPipe();

    return () => {
      if (videoRef.current && videoRef.current.srcObject) {
        const stream = videoRef.current.srcObject;
        stream.getTracks().forEach(track => track.stop());
      }
      if (handLandmarker) handLandmarker.close();
      cancelAnimationFrame(animationFrameId);
    };
  }, [onHandUpdate]);

  return React.createElement('div', { className: `fixed bottom-4 right-4 z-50 transition-all duration-300 ease-in-out ${isMinimized ? 'w-12 h-12' : 'w-32 h-24'}` },
    React.createElement('div', { className: `relative w-full h-full overflow-hidden bg-black border-2 border-yellow-600/50 shadow-2xl transition-all duration-300 ${isMinimized ? 'rounded-full' : 'rounded-xl'} group` },
      React.createElement('video', { ref: videoRef, autoPlay: true, playsInline: true, muted: true, className: `absolute inset-0 w-full h-full object-cover transform -scale-x-100 transition-opacity duration-300 ${isMinimized ? 'opacity-0' : 'opacity-60 hover:opacity-100'}` }),
      React.createElement('div', { className: `absolute inset-0 flex items-center justify-center transition-opacity duration-300 ${isMinimized ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'}` },
        React.createElement('button', { onClick: () => setIsMinimized(false), className: "w-full h-full flex items-center justify-center bg-black/40 backdrop-blur-md hover:bg-yellow-600/20 text-yellow-500", title: "显示摄像头" },
          React.createElement(IconChevronUp, { size: 24 }),
          React.createElement('div', { className: "absolute top-2 right-3 w-2 h-2 bg-green-500 rounded-full opacity-80 animate-pulse" })
        )
      ),
      React.createElement('div', { className: `absolute inset-0 transition-opacity duration-300 ${!isMinimized ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'}` },
        loading && React.createElement('div', { className: "absolute inset-0 flex items-center justify-center text-xs text-yellow-500 z-10" }, "Init AI..."),
        error && React.createElement('div', { className: "absolute inset-0 flex items-center justify-center text-xs text-red-500 z-10" }, error),
        React.createElement('button', { onClick: () => setIsMinimized(true), className: "absolute top-1 right-1 z-20 text-white/50 hover:text-white bg-black/30 rounded-full p-0.5 opacity-0 group-hover:opacity-100 transition-opacity" },
          React.createElement(IconChevronDown, { size: 14 })
        ),
        React.createElement('div', { className: "absolute bottom-1 left-2 text-[10px] text-white/70 pointer-events-none z-10" }, "Cam Feed")
      )
    )
  );
};

// ============================================
// UI OVERLAY COMPONENT
// ============================================
const UIOverlay = ({ onUpload, onDeletePhoto, onSaveGallery, photos, mode, currentGesture }) => {
  const [isGalleryOpen, setIsGalleryOpen] = useState(false);
  const [isInstructionsOpen, setIsInstructionsOpen] = useState(() => typeof window !== 'undefined' ? window.innerWidth >= 768 : true);
  const [isControlsOpen, setIsControlsOpen] = useState(() => typeof window !== 'undefined' ? window.innerWidth >= 768 : true);

  const handleSaveClick = () => {
      onSaveGallery();
      const btn = document.getElementById('save-btn-icon');
      if (btn) {
          btn.classList.add('text-green-400');
          setTimeout(() => btn.classList.remove('text-green-400'), 1000);
      }
  };

  return React.createElement('div', { className: "absolute inset-0 pointer-events-none flex flex-col justify-between p-4 md:p-6 z-10" },
    // Header
    React.createElement('header', { className: "flex justify-between items-start pointer-events-auto w-full" },
      React.createElement('div', { className: "text-left pointer-events-none select-none mt-2 ml-2 md:mt-0 md:ml-0" },
        React.createElement('h1', { className: "text-2xl md:text-5xl text-yellow-500 font-bold tracking-widest drop-shadow-[0_0_15px_rgba(212,175,55,0.8)] leading-tight opacity-80 md:opacity-100" },
          "Merry", React.createElement('br'), "Christmas"
        )
      ),
      React.createElement('div', { className: "flex flex-col items-end gap-2 pointer-events-auto" },
        isControlsOpen ? 
          React.createElement('div', { className: "flex gap-2 items-start" },
            React.createElement('button', { onClick: () => setIsGalleryOpen(true), className: "flex items-center gap-2 bg-white/5 border border-yellow-500/30 backdrop-blur-md px-3 py-2 md:px-4 rounded-full transition-all hover:bg-yellow-500/20 hover:border-yellow-500" },
              React.createElement(IconImage),
              React.createElement('span', { className: "text-yellow-100 text-xs md:text-sm font-light hidden sm:inline" }, `${photos.length} 照片`),
              React.createElement('span', { className: "text-yellow-100 text-xs md:text-sm font-light sm:hidden" }, photos.length)
            ),
            React.createElement('label', { className: "cursor-pointer group flex items-center gap-2 bg-yellow-600/20 border border-yellow-500/50 backdrop-blur-md px-3 py-2 md:px-4 rounded-full transition-all hover:bg-yellow-600/40 hover:border-yellow-400" },
              React.createElement('input', { type: "file", multiple: true, accept: "image/*", className: "hidden", onChange: onUpload }),
              React.createElement(IconUpload),
              React.createElement('span', { className: "text-yellow-100 text-xs md:text-sm font-light hidden sm:inline" }, "上传")
            ),
            React.createElement('button', { onClick: () => setIsControlsOpen(false), className: "bg-black/30 backdrop-blur-md p-2 rounded-full border border-white/10 hover:bg-white/10 text-white/70 transition-colors", title: "最小化" },
              React.createElement(IconChevronUp, { size: 18 })
            )
          )
        :
          React.createElement('button', { onClick: () => setIsControlsOpen(true), className: "bg-black/40 backdrop-blur-md p-3 rounded-full border border-yellow-600/50 hover:bg-yellow-600/20 text-yellow-500 transition-all shadow-lg hover:shadow-yellow-500/20", title: "展开菜单" },
            React.createElement(IconChevronDown, { size: 24 })
          )
      )
    ),

    // Gallery Modal
    isGalleryOpen && React.createElement('div', { className: "absolute inset-0 bg-black/80 backdrop-blur-lg flex items-center justify-center z-50 pointer-events-auto" },
      React.createElement('div', { className: "bg-[#1a1a1a] border border-yellow-500/30 rounded-2xl w-full max-w-2xl max-h-[80vh] flex flex-col overflow-hidden shadow-2xl m-4" },
        React.createElement('div', { className: "flex justify-between items-center p-6 border-b border-white/10" },
          React.createElement('div', { className: "flex items-center gap-4" },
            React.createElement('h2', { className: "text-xl text-yellow-500 font-serif" }, `照片库 (${photos.length})`),
            React.createElement('button', { onClick: handleSaveClick, className: "flex items-center gap-1.5 bg-yellow-600/20 border border-yellow-600/50 hover:bg-yellow-600/40 text-yellow-100 text-xs px-3 py-1.5 rounded-full transition-all", title: "保存照片到本地" },
              React.createElement(IconSave, { size: 14, id: "save-btn-icon", className: "transition-colors duration-300" }),
              React.createElement('span', null, "保存")
            )
          ),
          React.createElement('button', { onClick: () => setIsGalleryOpen(false), className: "text-white/50 hover:text-white transition-colors" },
            React.createElement(IconX, { size: 24 })
          )
        ),
        React.createElement('div', { className: "p-6 overflow-y-auto grid grid-cols-3 sm:grid-cols-4 gap-4" },
          photos.length === 0 && React.createElement('div', { className: "col-span-full text-center text-white/30 py-10 italic" }, "暂无照片，请点击右上角上传"),
          photos.map(photo => 
            React.createElement('div', { key: photo.id, className: "relative group aspect-square rounded-lg overflow-hidden border border-white/10 bg-white/5" },
              React.createElement('img', { src: photo.url, alt: "User Upload", className: "w-full h-full object-cover" }),
              React.createElement('button', { onClick: () => onDeletePhoto(photo.id), className: "absolute top-1 right-1 bg-red-500/80 p-1.5 rounded-full opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-500" },
                React.createElement(IconX, { size: 12 })
              )
            )
          )
        )
      )
    ),

    // Footer / Instructions
    React.createElement('div', { className: "flex justify-between items-end" },
      React.createElement('div', { className: "pointer-events-auto relative" },
        isInstructionsOpen ?
          React.createElement('div', { className: "bg-black/40 backdrop-blur-md p-3 md:p-4 rounded-xl border-l-2 border-yellow-600 w-fit transition-all duration-300 origin-bottom-left whitespace-nowrap" },
            React.createElement('div', { className: "flex justify-between items-center gap-4 mb-2 md:mb-3" },
              React.createElement('h3', { className: "text-yellow-500 font-serif text-xs md:text-sm tracking-widest uppercase" }, "手势控制"),
              React.createElement('button', { onClick: () => setIsInstructionsOpen(false), className: "text-white/50 hover:text-white p-1 hover:bg-white/10 rounded-full transition-colors" },
                React.createElement(IconChevronDown, { size: 20 })
              )
            ),
            React.createElement('div', { className: "flex flex-col gap-2 md:gap-3 text-xs md:text-sm text-gray-300" },
              React.createElement('div', { className: `flex items-center gap-2 md:gap-3 ${currentGesture === 'FIST' ? 'text-green-400 font-bold' : ''}` },
                React.createElement(IconGripHorizontal),
                React.createElement('span', { className: "leading-tight" }, "握拳：组合圣诞树")
              ),
              React.createElement('div', { className: `flex items-center gap-2 md:gap-3 ${currentGesture === 'OPEN_PALM' ? 'text-green-400 font-bold' : ''}` },
                React.createElement(IconHand),
                React.createElement('span', { className: "leading-tight" }, "张开手掌：散开")
              ),
              React.createElement('div', { className: `flex items-center gap-2 md:gap-3 ${currentGesture === 'PINCH' ? 'text-green-400 font-bold' : ''}` },
                React.createElement(IconMaximize),
                React.createElement('span', { className: "leading-tight" }, "双指捏合：抓取照片")
              ),
              React.createElement('div', { className: "flex items-center gap-2 md:gap-3" },
                React.createElement(IconRotateCcw),
                React.createElement('span', { className: "leading-tight" }, "移动手部：旋转视角")
              )
            )
          )
        :
          React.createElement('button', { onClick: () => setIsInstructionsOpen(true), className: "bg-black/40 backdrop-blur-md p-2 md:p-3 rounded-full border border-yellow-600/50 hover:bg-yellow-600/20 text-yellow-500 transition-all shadow-lg hover:shadow-yellow-500/20", title: "显示手势说明" },
            React.createElement(IconChevronUp, { size: 24 })
          )
      )
    )
  );
};

// ============================================
// MAIN APP COMPONENT
// ============================================
const App = () => {
  const [mode, setMode] = useState('ASSEMBLED');
  const [photos, setPhotos] = useState([]);
  const [handState, setHandState] = useState({
    gesture: 'NONE',
    position: { x: 0.5, y: 0.5 },
    rotation: 0,
    isPresent: false,
  });
  const [focusId, setFocusId] = useState(null);
  const nextPhotoIndex = useRef(0);

  const generateFramePosition = useCallback((index, totalExisting) => {
    const i = totalExisting + index;
    const minHPercent = 0.25, maxHPercent = 0.75;
    const heightRange = maxHPercent - minHPercent;
    const heightCycle = 15;
    const normalizedH = minHPercent + ((i % heightCycle) / heightCycle) * heightRange;
    const finalH = (normalizedH + (Math.random() * 0.04 - 0.02)) * CONFIG.TREE_HEIGHT;
    
    const rMaxAtH = (CONFIG.TREE_RADIUS_BOTTOM * (CONFIG.TREE_HEIGHT - finalH)) / CONFIG.TREE_HEIGHT;
    const rTree = rMaxAtH * (0.9 + Math.random() * 0.1);

    const goldenAngle = 2.39996;
    const thetaTree = i * goldenAngle;

    const tx = Math.cos(thetaTree) * rTree;
    const tz = Math.sin(thetaTree) * rTree;
    const ty = finalH - CONFIG.TREE_HEIGHT / 2;

    const rScatter = 6.0 + (i % 3) * 1.5 + Math.random();
    const verticalBand = 0.8;
    const rndY = ((i * 13) % 20) / 20;
    const safeY = (rndY - 0.5) * verticalBand;
    
    const phi = Math.acos(safeY);
    const thetaScatter = i * goldenAngle;

    const sx = rScatter * Math.sin(phi) * Math.cos(thetaScatter);
    const sy = rScatter * Math.cos(phi);
    const sz = rScatter * Math.sin(phi) * Math.sin(thetaScatter);

    return { treePosition: [tx, ty, tz], scatterPosition: [sx, sy, sz] };
  }, []);

  // Load local storage on mount
  useEffect(() => {
    const savedPhotos = loadFromStorage();
    if (savedPhotos && savedPhotos.length > 0) setPhotos(savedPhotos);
  }, []);

  // Load remote photos on mount
  useEffect(() => {
    const loadPhotos = async () => {
      const remoteUrls = await loadRemotePhotos();
      if (remoteUrls && remoteUrls.length > 0) {
        const remotePhotos = remoteUrls.map((url, index) => ({
          id: `remote-${index}-${Date.now()}`,
          url: url,
          aspectRatio: 1,
          ...generateFramePosition(index, 0)
        }));
        setPhotos(prev => {
          const localOnly = prev.filter(p => !p.id.startsWith('remote-'));
          return [...remotePhotos, ...localOnly];
        });
      }
    };
    loadPhotos();
  }, [generateFramePosition]);

  const handleUpload = async (e) => {
    if (e.target.files && e.target.files.length > 0) {
      const files = Array.from(e.target.files);
      const currentCount = photos.length;
      const newPhotos = [];

      for (let i = 0; i < files.length; i++) {
        try {
          const base64Url = await processImageFile(files[i]);
          newPhotos.push({
            id: uuidv4(),
            url: base64Url,
            aspectRatio: 1,
            ...generateFramePosition(i, currentCount)
          });
        } catch (err) {
          console.error("Error processing file:", files[i].name, err);
        }
      }

      setPhotos(prev => [...prev, ...newPhotos]);
    }
  };

  const handleDeletePhoto = useCallback((id) => {
    setPhotos(prev => {
        const newPhotos = prev.filter(p => p.id !== id);
        saveToStorage(newPhotos);
        return newPhotos;
    });
    if (focusId === id) {
        setMode('DISPERSED');
        setFocusId(null);
    }
  }, [focusId]);

  const handleSaveGallery = useCallback(() => {
      const success = saveToStorage(photos);
      if (success) console.log("Gallery Saved!");
  }, [photos]);

  useEffect(() => {
    if (!handState.isPresent) return;

    if (handState.gesture === 'FIST' && mode !== 'ASSEMBLED') {
      setMode('ASSEMBLED');
      setFocusId(null);
    } else if (handState.gesture === 'OPEN_PALM') {
       if (mode === 'ASSEMBLED') setMode('DISPERSED');
       else if (mode === 'FOCUS') { setMode('DISPERSED'); setFocusId(null); }
    } else if (handState.gesture === 'PINCH' && mode === 'DISPERSED') {
      if (!focusId && photos.length > 0) {
        setMode('FOCUS');
        const index = nextPhotoIndex.current % photos.length;
        setFocusId(photos[index].id);
        nextPhotoIndex.current += 1;
      }
    }
  }, [handState.gesture, handState.isPresent, mode, photos, focusId]);

  const onHandUpdate = useCallback((newState) => setHandState(newState), []);

  return React.createElement('div', { className: "w-full h-screen relative bg-black overflow-hidden" },
    React.createElement(Experience, { mode, photos, rotationOffset: handState.rotation, focusId }),
    React.createElement(UIOverlay, { onUpload: handleUpload, onDeletePhoto: handleDeletePhoto, onSaveGallery: handleSaveGallery, mode, currentGesture: handState.gesture, photos }),
    React.createElement(HandTracker, { onHandUpdate })
  );
};

// ============================================
// MOUNT APPLICATION
// ============================================
const rootElement = document.getElementById('root');
if (!rootElement) throw new Error("Could not find root element");

const root = createRoot(rootElement);
root.render(React.createElement(React.StrictMode, null, React.createElement(App)));
  </script>
</body>
</html>
